package unittest;

import java.util.Arrays;
import java.util.List;
import java.util.Random;
import misc.Utils;
import model.skipgraph.SkipGraph;

/**
 * Contains fixtures used for developing unit tests.
 */
public class Fixtures {
  private final static Random random = new Random();

  /**
   * Generates a random byte array.
   * @param length length of byte array.
   * @return random byte array.
   */
  public static byte[] ByteArrayFixture(int length){
    byte[] arr = new byte[length];
    random.nextBytes(arr);
    return arr;
  }

  /**
   * Generates a byte array with all values at minimum byte value, i.e., -127.
   * @param length length of byte array.
   * @return byte array.
   */
  public static byte[] MinByteArrayFixture(int length){
    byte[] arr = new byte[length];
    Arrays.fill(arr, Byte.MIN_VALUE);
    return arr;
  }

  /**
   * Generates a byte array with all values at maximum byte value, i.e., 128.
   * @param length length of byte array.
   * @return byte array.
   */
  public static byte[] MaxByteArrayFixture(int length){
    byte[] arr = new byte[length];
    Arrays.fill(arr, Byte.MAX_VALUE);
    return arr;
  }

  public static byte[]ByteArrayFixture(String prefix, int length){
    if(prefix.length() > length){
      throw new IllegalArgumentException("prefix (" + prefix + ") must be less than or equal to length ("+ length + ")");
    }

    byte[] fixtureByte = new byte[length];

    // converting prefix to byte
    int index = 0;
    List<String> prefixSplit = Utils.splitEqually(prefix, SkipGraph.BYTE_SIZE);
    for(String str: prefixSplit){
      if(str.length() < SkipGraph.BYTE_SIZE){
        fixtureByte[index++] = ByteFixtureWithZeroPrefix(str);
      } else {
        fixtureByte[index++] = Byte.parseByte(str, 2);
      }
    }

    int remainSize = length - index;
    byte[] remainBytes = ByteArrayFixture(remainSize);
    System.arraycopy(remainBytes, 0, fixtureByte, index, remainSize);

    return fixtureByte;
  }


  /**
   * Returns a byte fixture that always starts with zero bit. Note that in Java an 8-bit byte represents
   * a value between -128 (10000000) to 127 (01111111). So, we can't represent any byte that starts with 1
   * and has subsequent 1s, e.g., 10100000, since it will be below -128 in 2's complement.
   * @param prefix at most 7-bits prefix.
   * @return a randomly generated byte with 0 + prefix + random bits pattern.
   */
  public static byte ByteFixtureWithZeroPrefix(String prefix){
    if(prefix.length() > SkipGraph.BYTE_SIZE - 1){
      throw new IllegalArgumentException("prefix (" + prefix + ") must be at most 7 bits");
    }

    StringBuilder bStr = new StringBuilder("0" + prefix); // byte always starts with zero
    // converting prefix to byte
    for(int i = 0; i < (SkipGraph.BYTE_SIZE - 1) - prefix.length(); i++){
      if(random.nextBoolean()){
        bStr.append("1");
      } else {
        bStr.append("0");
      }
    }

    return Byte.parseByte(bStr.toString(), 2);
  }



}
