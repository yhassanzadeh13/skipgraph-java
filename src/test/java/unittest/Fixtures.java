package unittest;

import java.util.Arrays;
import java.util.List;
import java.util.Random;
import misc.Utils;
import model.skipgraph.SkipGraph;

/**
 * Contains fixtures used for developing unit tests.
 */
public class Fixtures {
  private final static Random random = new Random();

  /**
   * Generates a random byte array.
   * @param length length of byte array.
   * @return random byte array.
   */
  public static byte[] ByteArrayFixture(int length){
    byte[] arr = new byte[length];
    random.nextBytes(arr);
    return arr;
  }

  /**
   * Generates a byte array with all values at minimum byte value, i.e., -127.
   * @param length length of byte array.
   * @return byte array.
   */
  public static byte[] MinByteArrayFixture(int length){
    byte[] arr = new byte[length];
    Arrays.fill(arr, Byte.MIN_VALUE);
    return arr;
  }

  /**
   * Generates a byte array with all values at maximum byte value, i.e., 128.
   * @param length length of byte array.
   * @return byte array.
   */
  public static byte[] MaxByteArrayFixture(int length){
    byte[] arr = new byte[length];
    Arrays.fill(arr, Byte.MAX_VALUE);
    return arr;
  }

  public static byte[]ByteArrayFixture(String prefix, int length){
    if(prefix.length() > length){
      throw new IllegalArgumentException("prefix (" + prefix + ") must be less than or equal to length ("+ length + ")");
    }

    byte[] fixtureByte = new byte[length];

    // converting prefix to byte
    int index = 0;
    List<String> prefixSplit = Utils.splitEqually(prefix, SkipGraph.BYTE_SIZE);
    for(String str: prefixSplit){
      if(str.length() < SkipGraph.BYTE_SIZE){
        fixtureByte[index++] = ByteFixture(str);
      } else {
        fixtureByte[index++] = Byte.parseByte(str, 2);
      }
    }

    int remainSize = length - index;
    byte[] remainBytes = ByteArrayFixture(remainSize);
    System.arraycopy(remainBytes, 0, fixtureByte, index, remainSize);

    return fixtureByte;
  }


  /**
   * Returns a byte fixture. Note that in Java an 8-bit byte represents
   * a value between -128 (10000000) to 127 (01111111). So, we can't represent any byte that starts with 1
   * and has more subsequent 1s, e.g., 10100000, since it will be below -128 in 2's complement.
   * @param prefix at most 8-bits prefix.
   * @return a randomly generated byte starting with the prefix.
   * @throws IllegalArgumentException when prefix length is larger than byte size, or starts with 1 and contains more
   *         subsequent ones.
   */
  public static byte ByteFixture(String prefix) throws IllegalArgumentException{
    if(prefix.length() > SkipGraph.BYTE_SIZE){
      throw new IllegalArgumentException("prefix (" + prefix + ") must be at most 8 bits");
    }
    if(prefix.startsWith("1")){
      if(prefix.chars().filter(c -> c == '1').count() > 1){
        // we can't go beyond -128 in bytes.
        throw new IllegalArgumentException("prefixes starting with 1 should not have any more subsequent ones");
      } else {
        // only byte value starting with 1 is 10000000 which is the byte min value
        return Byte.MIN_VALUE;
      }
    }

    StringBuilder bStr = new StringBuilder(prefix); // byte always starts with zero
    // converting prefix to byte
    for(int i = 0; i < (SkipGraph.BYTE_SIZE) - prefix.length(); i++){
      if(random.nextBoolean()){
        bStr.append("1");
      } else {
        bStr.append("0");
      }
    }

    return Byte.parseByte(bStr.toString(), 2);
  }



}
